#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <functional>
#include <unordered_set>
#include <queue>
#include "Day19Solver.h"

struct Replacement
{
    std::string initial;
    std::string final;
};

// Returns a vector of all possible strings that can be generated by applying one replacement to the
// initial_molecule.
std::vector<std::string> get_all_replacements(std::string initial_molecule, std::vector<Replacement> replacements)
{
    std::vector<std::string> final_molecules;

    int max_initial_size = 0;
    for (Replacement replacement : replacements)
    {
        if (replacement.initial.size() > max_initial_size)
        {
            max_initial_size = replacement.initial.size();
        }
    }

    // For every character, check if either that character on its own or up to max_initial_size
    // characters made from the current character and preceding characters can be replaced.
    for (int i = 0; i < initial_molecule.size(); i++)
    {
        // j + 1 represents the number of characters in the string. Check every combination of
        // character numbers up until the maximum size of initial_molecules in replacements.
        std::vector<std::string> n_character_element = {};
        for (int j = 0; j < max_initial_size; j++)
        {
            // Don't go back past the start of the initial_molecule string.
            if (i - j < 0)
            {
                break;
            }
            else
            {
                // Get a substring starting at character i and going j characters back.
                n_character_element.push_back(initial_molecule.substr(i - j, j + 1));
            }
        }

        for (Replacement replacement : replacements)
        {
            for (int j = 0; j < n_character_element.size(); j++)
            {
                if (n_character_element[j] == replacement.initial)
                {
                    std::string final_molecule = initial_molecule.substr(0, i - j) + replacement.final + initial_molecule.substr(i + 1);
                    final_molecules.push_back(final_molecule);
                }
            }
        }
    }

    return final_molecules;
}

std::string AdventOfCode2015::Day19Solver::SolvePart1()
{
    std::ifstream infile("PuzzleInputs/19.txt");
    std::string line;

    std::vector<Replacement> replacements = {};
    std::string initial_molecule;

    while (getline(infile, line))
    {
        int initial_length = line.find(" => ");
        if (initial_length != std::string::npos)
        {
            // The initial element is all the characters up to " => ".
            std::string initial_element = line.substr(0, initial_length);
            // The final element is all the characters after the length of the initial element plus
            // the length of " => " (4).
            std::string final_elements = line.substr(initial_length + 4);

            replacements.push_back(Replacement{.initial = initial_element, .final = final_elements});
        }
        else
        {
            // Skip the empty line.
            if (line.size() != 0)
            {
                initial_molecule = line;
            }
        }
    }

    std::vector<std::string> final_molecules = get_all_replacements(initial_molecule, replacements);

    // Remove all duplicates in final_molecules by copying all of its elements to an unordered_map,
    // since adding an element to an unordered_map will have no effect if it already contains the
    // element.
    std::unordered_set<std::string> distinct_final_molecules = {};
    for (std::string final_molecule : final_molecules)
    {
        distinct_final_molecules.emplace(final_molecule);
    }

    return std::to_string(distinct_final_molecules.size());
}

std::string AdventOfCode2015::Day19Solver::SolvePart2()
{
    return "0";

    // As far as I can tell, this is a theoretically working solution to part 2. However, based on
    // my testing of the code, this solution will take multiple days to complete at minimum
    // (possibly weeks) and runs a very high risk of running out of available memory. Given that all
    // Advent of Code challenges have a solution that runs under 15 seconds, clearly this solution
    // is not a practical solution.
    //
    // However, this deeply confuses me, because I would be completely confident that the algorithm
    // I have designed here is the fastest possible solution if I found this puzzle in any context
    // outside of Advent of Code. The crux of the problem is that when I find a path that goes from
    // "e" to the target molecule, I need to ensure that this path takes the fewest possible steps.
    // The only way to know that it takes the fewest possible steps is to check every path with
    // fewer steps and confirm that none of them lead to the target molecule. By doing a breadth-
    // first to check all paths of a given number of steps before moving onto paths with a greater
    // number of steps, every path up until the target molecule is checked exactly once, making it
    // the most efficient way possible to check every path of fewer steps.
    //
    // I have extremely closely analysed my logic for days, but cannot find any flaw in it, even
    // despite knowing there must exist a flaw because otherwise this puzzle wouldn't be an Advent
    // of Code puzzle. There must exist some other algorithm to find the shortest path to the target
    // molecule which is thousands of times faster than breadth-first search, despite such an
    // algorithm sounding obviously impossible to me.
    //
    // The only additional insight I've made is that there are four elements (C, Rn, Ar, and Y) that
    // are not the initial element for any replacements. Thus once they are created, they are stuck
    // where they are in the target molecule. Perhaps closely analysing where they appear in the
    // string can prune some paths early, but I can only see such pruning leading to about a 2x
    // speedup at most, nowhere close to the thousands of time speedup I require. I'm guessing there
    // are even more subtle relationships in the replacements that can lead to even further
    // speedups, but so far I haven't been able to find any further patterns. And even if I do find
    // such patterns, I'd be hesitant to exploit them because I don't want to take advantage of
    // simply getting lucky with my randomly-generated puzzle input.
    //
    // I am completely stumped on this puzzle, so I am skipping it for now. As this code will take
    // at least several days to complete if it was run, I have commented out so it doesn't get in
    // the way of running the rest of my solutions.

    // std::ifstream infile("PuzzleInputs/19.txt");
    // std::string line;

    // std::vector<Replacement> replacements = {};
    // std::string target_molecule;

    // while (getline(infile, line))
    // {
    //     int initial_length = line.find(" => ");
    //     if (initial_length != std::string::npos)
    //     {
    //         std::string initial_element = line.substr(0, initial_length);
    //         std::string final_elements = line.substr(initial_length + 4);

    //         // For part 2, the replacements will be applied in reverse order (starting from the
    //         // target_molecule and working down to "e") so reverse the order of each replacement.
    //         replacements.push_back(Replacement{.initial = final_elements, .final = initial_element});
    //     }
    //     else
    //     {
    //         // Skip the empty line.
    //         if (line.size() != 0)
    //         {
    //             target_molecule = line;
    //         }
    //     }
    // }

    // struct MoleculeAndDepth
    // {
    //     std::string molecule;
    //     int depth;
    // };

    // std::queue<MoleculeAndDepth> molecule_steps = {};
    // std::unordered_set<std::string> distinct_final_molecules = {};
    // molecule_steps.push(MoleculeAndDepth{.molecule = target_molecule, .depth = 1});

    // bool found_target_molecule = false;
    // int steps_to_target_molecule;

    // // Perform a breadth-first search, treating every applicable replacement as a branch on a tree,
    // // until a path is found that leads to the final_molecule. Because breadth-first search searches
    // // all paths of a given depth before moving onto the next depth, the first final_molecule found
    // // is guaranteed to be the shortest (or tied for the shortest) path to the final_molecule.
    // while (!found_target_molecule && !molecule_steps.empty())
    // {
    //     MoleculeAndDepth molecule_and_depth = molecule_steps.front();
    //     molecule_steps.pop();

    //     std::vector<std::string> next_molecule_steps = get_all_replacements(molecule_and_depth.molecule, replacements);

    //     for (std::string next_molecule_step : next_molecule_steps)
    //     {
    //         if (next_molecule_step == "e")
    //         {
    //             found_target_molecule = true;
    //             steps_to_target_molecule = molecule_and_depth.depth;
    //         }
    //         // the .emplace method returns a std::pair whose second element indicates whether the
    //         // unordered_map already had the element (false) or not (true).
    //         else if (distinct_final_molecules.emplace(next_molecule_step).second)
    //         {
    //             molecule_steps.push(MoleculeAndDepth{.molecule = next_molecule_step, .depth = molecule_and_depth.depth + 1});
    //         }
    //     }
    // }

    // return std::to_string(steps_to_target_molecule);
}