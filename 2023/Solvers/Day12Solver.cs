namespace AdventOfCode2023;

class Day12Solver : Solver
{
    private string _puzzleTitle = "Hot Springs";
    private string _puzzleInputPath = "PuzzleInputs/12.txt";
    public override string PuzzleTitle { get => _puzzleTitle; }
    public override string PuzzleInputPath { get => _puzzleInputPath; }

    public override long SolvePart1()
    {
        int validConfigurationSum = 0;
        string[] lines = File.ReadAllLines(PuzzleInputPath);
        foreach (string line in lines)
        {
            string[] splitLine = line.Split(' ');
            string springConditionRecord = splitLine[0];
            string contiguousGroupsLine = splitLine[1];
            int[] contiguousGroups = GetNumbersFromString(contiguousGroupsLine);

            validConfigurationSum += GetNumberOfValidConfigurations(springConditionRecord, contiguousGroups);
        }

        return validConfigurationSum;
    }

    public override long SolvePart2()
    {
        string[] lines = File.ReadAllLines(PuzzleInputPath);

        return 0;
    }


    int GetNumberOfValidConfigurations(string springConditionRecord, int[] contiguousGroups)
    {
        int validConfigurations = 0;
        int unknownStringsCount = springConditionRecord.Count(spring => spring == '?');
        // Compute 2^unknownStringsCount using left-shifts (each left-shift corresponds to a multiplication by 2).
        // This computes a number one greater than the highest index (when all bits corresponding to an unknown '?' spring are 1).
        uint maxConfigurationIndex = 1u << unknownStringsCount;

        // configurationIndex will keep track of which configurations have already been checked, by having each possible configuration be generated by bitwise operations on configurationIndex.
        // The rightmost bit corresponds to the first unknown '?' spring, with 0 denoting it's damaged '#' and 1 denoting it's operational '.'
        for (uint configurationIndex = 0; configurationIndex < maxConfigurationIndex; configurationIndex++)
        {
            string prospectiveSpringConfiguration = springConditionRecord;

            // Iterate over each bit in configurationIndex.
            for (uint bit = 1; bit < maxConfigurationIndex; bit = bit << 1)
            {
                // To tell if the current bit of configurationIndex is a 1, perform a bitwise AND between them and check if it's greater than 0.
                if ((configurationIndex & bit) > 0)
                {
                    prospectiveSpringConfiguration = prospectiveSpringConfiguration.ReplaceFirstQuestionMark('.');
                }
                else
                {
                    prospectiveSpringConfiguration = prospectiveSpringConfiguration.ReplaceFirstQuestionMark('#');
                }
            }

            if (isValidConfiguration(prospectiveSpringConfiguration, contiguousGroups)) validConfigurations++;
        }

        return validConfigurations;
    }

    bool isValidConfiguration(string springConfiguration, int[] contiguousGroups)
    {
        bool foundAllDamagedSprings = false;
        bool expectBlank = false;

        int nextContiguousGroup = contiguousGroups[0];
        int nextContiguousGroupIndex = 1;

        for (int i = 0; i < springConfiguration.Length; i++)
        {
            char spring = springConfiguration[i];

            // expectBlank is set true whenever a group of damaged springs equal to the current contiguous group size is found.
            // If an additional damaged spring is found now, it means the group of damaged springs was actually larger than the contiguous group specified, so the configuration isn't valid.
            // Set expectBlank back to false after checking once, since any damaged spring that appears after this is the beginning of the next contiguous group.
            if (expectBlank)
            {
                if (spring == '#') return false;
                else expectBlank = false;
            }

            if (spring == '#')
            {
                // foundAllDamagedSprings is set true when the end of the last contiguous group is found.
                // If an additional damaged spring is found after this, it means there's an additional contiguous group beyond what is specified, so the configuration isn't valid.
                if (foundAllDamagedSprings) return false;

                for (int j = 1; j < nextContiguousGroup; j++)
                {
                    // Manually iterate i through the rest of the contiguous group.
                    i++;
                    // If i reaches the end of the spring configuration before the end of the contiguous group, then the contiguous group started too late to fit into the configuration, so the configuration isn't valid.
                    // This check is especially important to avoid an ArgumentOutOfRangeException on the next line.
                    if (i >= springConfiguration.Length) return false;

                    // If an undamaged spring is found before the end of the contiguous group, then the group is too small, so the configuration isn't valid.
                    char springInGroup = springConfiguration[i];
                    if (springInGroup == '.') return false;
                }

                // The end of a contiguous group was reached, so check that the next spring is an undamaged one.
                expectBlank = true;

                // Check if all springs have been found now. If so, set the appropriate flag, otherwise move onto the next contiguous group.
                if (nextContiguousGroupIndex == contiguousGroups.Length)
                {
                    foundAllDamagedSprings = true;
                }
                else
                {
                    nextContiguousGroup = contiguousGroups[nextContiguousGroupIndex];
                    nextContiguousGroupIndex++;
                }
            }
        }

        // If the code reaches this point, then the entire spring configuration has been checked without anything invalidating it.
        // The only possible remaining error is that not enough springs were found in the configuration, so return the state of the flag checking if all springs were found.
        return foundAllDamagedSprings;
    }

    int[] GetNumbersFromString(string input)
    {
        string[] splitInput = input.Split(',');
        int[] numbers = splitInput.Select(x => int.Parse(x)).ToArray();
        return numbers;
    }
}

// Implement a string method that replaces the first question mark only with the specified character.
public static class StringExtension
{
    public static string ReplaceFirstQuestionMark(this string text, char replace)
    {
        int position = text.IndexOf('?');
        return text.Substring(0, position) + replace + text.Substring(position + 1);
    }
}
